<!DOCTYPE html>
<html>
<head>
    <title>Thread Blocking vs Non-Blocking Load Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .blocking { background-color: #ffebee; border-color: #f44336; }
        .non-blocking { background-color: #e8f5e8; border-color: #4caf50; }
        button { padding: 10px 20px; margin: 5px; font-size: 16px; cursor: pointer; }
        .blocking-btn { background-color: #f44336; color: white; }
        .non-blocking-btn { background-color: #4caf50; color: white; }
        .results { margin-top: 10px; max-height: 300px; overflow-y: auto; background: #f5f5f5; padding: 10px; }
        .stats { background: #e3f2fd; padding: 10px; margin: 10px 0; border-radius: 3px; }
        .request-item { margin: 5px 0; padding: 5px; background: white; border-left: 3px solid #2196f3; }
        .blocked { border-left-color: #f44336; }
        .non-blocked { border-left-color: #4caf50; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Thread Blocking vs Non-Blocking Load Test</h1>
        
        <div class="stats">
            <h3>Current Stats</h3>
            <div id="threadStats">Loading...</div>
            <div id="concurrentStats">Loading...</div>
            <button onclick="refreshStats()">Refresh Stats</button>
        </div>

        <div class="section blocking">
            <h2>ðŸš« Blocking Methods (BAD for scalability)</h2>
            <p>These methods block the HTTP request thread, limiting server capacity.</p>
            <button class="blocking-btn" onclick="testBlocking(1)">Test Single Blocking Request</button>
            <button class="blocking-btn" onclick="loadTestBlocking(5)">Load Test 5 Blocking Requests</button>
            <button class="blocking-btn" onclick="loadTestBlocking(10)">Load Test 10 Blocking Requests</button>
            <div class="results" id="blockingResults"></div>
        </div>

        <div class="section non-blocking">
            <h2>âœ… Non-Blocking Methods (GOOD for scalability)</h2>
            <p>These methods free the HTTP request thread, allowing better server capacity.</p>
            <button class="non-blocking-btn" onclick="testNonBlocking(1)">Test Single Non-Blocking Request</button>
            <button class="non-blocking-btn" onclick="loadTestNonBlocking(5)">Load Test 5 Non-Blocking Requests</button>
            <button class="non-blocking-btn" onclick="loadTestNonBlocking(10)">Load Test 10 Non-Blocking Requests</button>
            <div class="results" id="nonBlockingResults"></div>
        </div>

        <div class="section">
            <h2>ðŸ“Š Comparison</h2>
            <p><strong>Key Differences:</strong></p>
            <ul>
                <li><strong>Blocking:</strong> Same thread ID for caller and worker = HTTP thread is blocked</li>
                <li><strong>Non-Blocking:</strong> Different thread IDs = HTTP thread is freed immediately</li>
                <li><strong>Scalability:</strong> Non-blocking allows server to handle more concurrent requests</li>
                <li><strong>Thread Pool:</strong> Blocking can exhaust the thread pool under load</li>
            </ul>
        </div>
    </div>

    <script>
        const baseUrl = window.location.origin;

        async function refreshStats() {
            try {
                const [threadResponse, concurrentResponse] = await Promise.all([
                    fetch(`${baseUrl}/threadPoolStats`),
                    fetch(`${baseUrl}/concurrentStats`)
                ]);
                
                const threadStats = await threadResponse.text();
                const concurrentStats = await concurrentResponse.text();
                
                document.getElementById('threadStats').textContent = threadStats;
                document.getElementById('concurrentStats').textContent = concurrentStats;
            } catch (error) {
                console.error('Error fetching stats:', error);
            }
        }

        async function testBlocking(requestId) {
            const startTime = Date.now();
            try {
                const response = await fetch(`${baseUrl}/loadTestBlocking/${requestId}`);
                const result = await response.text();
                const duration = Date.now() - startTime;
                addResult('blockingResults', result, 'blocked');
            } catch (error) {
                addResult('blockingResults', `Error: ${error.message}`, 'blocked');
            }
        }

        async function testNonBlocking(requestId) {
            const startTime = Date.now();
            try {
                const response = await fetch(`${baseUrl}/loadTestNonBlocking/${requestId}`);
                const result = await response.text();
                const duration = Date.now() - startTime;
                addResult('nonBlockingResults', result, 'non-blocked');
            } catch (error) {
                addResult('nonBlockingResults', `Error: ${error.message}`, 'non-blocked');
            }
        }

        async function loadTestBlocking(count) {
            clearResults('blockingResults');
            addResult('blockingResults', `Starting load test with ${count} blocking requests...`, 'blocked');
            
            const promises = [];
            for (let i = 1; i <= count; i++) {
                promises.push(testBlocking(i));
            }
            
            await Promise.all(promises);
            addResult('blockingResults', `Completed ${count} blocking requests`, 'blocked');
            refreshStats();
        }

        async function loadTestNonBlocking(count) {
            clearResults('nonBlockingResults');
            addResult('nonBlockingResults', `Starting load test with ${count} non-blocking requests...`, 'non-blocked');
            
            const promises = [];
            for (let i = 1; i <= count; i++) {
                promises.push(testNonBlocking(i));
            }
            
            await Promise.all(promises);
            addResult('nonBlockingResults', `Completed ${count} non-blocking requests`, 'non-blocked');
            refreshStats();
        }

        function addResult(containerId, text, type) {
            const container = document.getElementById(containerId);
            const div = document.createElement('div');
            div.className = `request-item ${type}`;
            div.textContent = `${new Date().toLocaleTimeString()}: ${text}`;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function clearResults(containerId) {
            document.getElementById(containerId).innerHTML = '';
        }

        // Load initial stats
        refreshStats();
    </script>
</body>
</html>
